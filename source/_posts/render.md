---
layout: simple-article
title: Web渲染小结
categories:
    - 服务器端渲染
    - 浏览器端渲染
tags:
    - 渲染
---
渲染类型：
- SSR：服务器端渲染
- CSR：客户端渲染
- Rehydration：在服务器端渲染的基础上，客户端利用 JS 再次渲染

性能指标：
- TTFB(time to first byte)：浏览器发出资源请求到接受到资源的第一个字节。
- FP(first paint)：页面打开到可视内容的第一个像素渲染出来的时间。
- FCP(first contentful paint)：页面打开到页面主要内容可见的时间
- TTI(time to interactive)：页面打开到可以交互的时间

获得指标：
- 在 Chrome dev tools 的 network 面板中查看每个请求的 timing 来得到 TTFB
- 在 Chrome dev tools 的 Performance 面板中录制整个加载过程可以看到 FP、FCP
- 在 Chrome dev tools 的 Audits 面板中对网站的 performance 进行 run audits 可以获取 FP、FCP、TTI

<!-- more -->

### 一. 服务器端渲染(SSR)

**原理**：服务器端直接返回填充了数据的HTML，浏览器端只需要使用 JS 绑定事件处理逻辑。

**优点**：服务器端渲染可以带来快速的 FP、FCP、TTI

**缺点**：由于服务器端进行渲染，所以请求的 TTFB 可能比较大

#### 1. 特例：静态化渲染

**应用场景**：当可以预先知道页面会渲染哪些数据（比如展示型页面），那么可以将页面在构建时直接输出 HTML，需要时直接返回 HTML，提高了 TTFB。

**原理**：构建时，将页面内容直接渲染出来，然后打到 HTML 中去。

**优点**：由于浏览器端还是只需要进行绑定事件处理，因此它可以带来快速的 FP、FCP、TTI；页面是直接返回的，这样就带来了快速的 TTFB。

**缺点**：静态化渲染会预先渲染页面部分的HTML并存储，因此需要针对每个 URL 都预先渲染一个 HTML

### 二. 客户端渲染

**原理**：服务器端返回资源，业务逻辑、数据获取、路由等等都由浏览器执行 JS 来完成。

**优点**：
  - 局部刷新：不需要每次都进行完整页面请求
  - 按需加载：可以在页面加载时只加载可视区域的数据，滚动后加载其他数据
  - 节约服务器成本

**缺点**：
  - 首屏性能比较差：因为要下载并执行 JS 才有页面，所以有比较慢的 FP、FCP、TTI
  - SEO 不太好

#### 1. 特例：预渲染

**原理**：在当前页面对即将跳转的页面进行预渲染，浏览器会提前请求需要的资源并渲染，这样在点击跳转后就能快速呈现页面

**优点**：可以实现快速的 FP 和 FCP

**缺点**：必须在执行 JS 代码之后才变得可交互，因此 TTI 还是比较慢


### 三. Rehydration

**原理**：Rehydration 想综合服务器端渲染和客户端渲染的优点。客户端渲染都好，就是首屏性能太慢。所以它的渲染方式就是首屏性能通过服务器端渲染来提升，之后的渲染由客户端渲染来接管。

**优点**：FP 和 FCP 相比纯客户端渲染变快了，首屏性能提升

**缺点**：
  - Rehydration 在服务器端渲染的基础上需要更多资源，因此 TTFB 更加慢
  - 虽然首屏性能提升，但是还是要等 JS 执行才可以交互，所以 TTI 还是很慢，但是它又有更快的 FCP，所以用户在看到页面内容后可能需要很长时间才可以进行交互。
  - 服务器端返回的 HTML 不光要有渲染好的HTML，还要有对当前 HTML 的数据描述，方便客户端渲染接管，但是这造成了数据的重复。

**应用场景**：由于以上缺点，目前还不建议使用

### 四. 总结
![](/images/web-render.webp)

目前的最佳实践是：混用服务器端渲染和客户端渲染。

具体来说：
- 对首页或者登录页面（重展示页面）之类的门户页面使用服务器端渲染，提升首屏性能
- 在重展示页面中，对之后的客户端渲染需要的的资源进行预加载，加快后续页面（重交互页面）的加载过程。
